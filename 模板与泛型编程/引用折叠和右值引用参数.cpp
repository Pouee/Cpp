#include "iostream"
using namespace std;
template<typename T>
void f3(T&& t) { t = 10000; }
void f4(int&& t) {}
int main()
{
	int i = 100;
	const int ci = 200;

	// 当一个函数参数是一个右值引用时,正常的绑定规则告诉我们可以传递给它一个右值
	f3(43);		// 成功 T被推断为int
	// 通常我们不能将一个右值引用绑定到一个左值上.但是C++语言在正常绑定规则之外定
	// 义了两个例外规则,允许这种绑定.这两个例外规则是move这种标准库设施正确工作的
	// 基础
	// 第一个例外规则影响右值引用参数的的推断如何进行.
	// 当我们将一个左值(如 i )传递给函数的右值引用参数,且此右值引用指向模板类型参
	// 数(如 T&&)时,编译器推断模板类型参数为实参的左值引用类型.
	// 
	f3(i);		// 正确	T被推断为int &
	// T 被推断为int &看起来好像意味着f3的函数参数应该是一个类型int&的右值引用
	// 通常我们不能(直接)定义一个引用的引用.
	// 在这种情况下我们可以使用第二个例外绑定规则:如果我们间接的创建一个引用的引
	// 用,则这些引用形成了"折叠",对于任意给定类型X:
	// X& &,X & &&, X&& &都折叠成类型 X&
	// X&& && 折叠成 X&&
	// 引用折叠只能应用于间接创建的引用的引用,如类型别名或参数模板
	f3(i);		// 正确	T被推断为int & 
	f3(ci);		// 正确	T被推断为const int & 
	// 这两个规则导致了两个重要的结果:
	// 如果一个函数参数是一个指向模板类型的右值引用(如,T&&),则它可以被绑定到一个
	// 左值;且
	// 如果实参是一个左值,则推断出的模板实参类型将是一个左值引用,且函数参数将被实
	// 例化一个(普通)左值引用参数(T&)

	// 如果一个函数参数是指向模板参数类型的右值引用(如T&&),则可以传递给它任意类型
	// 的实参.如果将一个左值传递给这样的参数,函数参数将被实例化一个(普通)左值引用
	// 参数(T&)

	//f4(i);	// 错误 此右值不指向模板类型参数
	cout << i << endl;
	system("pause");
	return 0; 
}